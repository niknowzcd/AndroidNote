### Android平台图像压缩方案 ###



**Bitmap.java中的主要变量**



> 像素密度



像素密度指的是每英寸像素数目，在Bitmap里用mDensity/mTargetDensity，mDensity默认是设备屏幕的像素密度，mTargetDensity是图片的目标像素密度，在加载图片时就是 drawable 目录的像素密度。



> 色彩模式->色彩模式是数字世界中表示颜色的一种算法，在Bitmap里用Config来表示。



- ARGB_8888：每个像素占四个字节，A、R、G、B 分量各占8位，是 Android 的默认设置；

- RGB_565：每个像素占两个字节，R分量占5位，G分量占6位，B分量占5位；

- ARGB_4444：每个像素占两个字节，A、R、G、B分量各占4位，成像效果比较差；

- Alpha_8: 只保存透明度，共8位，1字节；



> Bitmap的计算方式



    memory=scaledWidth*scaledHeight*每个像素所占字节数



其中  

scaledWidth :  width*targetDensity/density+0.5  

scaledHeight： height*targetDensity/density+0.5



- `scaledWidth`表示水平方向的像素值,  

- `width`表示屏幕宽度,  

- `targetDensity`表示手机的像素密度,这个值一般跟手机相关,  

- `density`表示decodingBitmap 的 density,这个值一般跟图片放置的目录有关(hdpi/xxhdpi)



scaledHeight同理



**每个像素所占字节数**:这个值跟色彩模式相关，默认 ARGB_8888 则是4个字节，



在Bitmap种又两个获取内存占用大小的方法



- getByteCount()：API12 加入，代表存储 Bitmap 的像素需要的最少内存。

- getAllocationByteCount()：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 getByteCount() 方法。



> 两者的区别:



在不复用 Bitmap 时，getByteCount() 和 getAllocationByteCount 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 getByteCount() 表示新解码图片占用内存的大小，getAllocationByteCount() 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。



## 图片压缩方式 ##



### 质量压缩 ###



> 质量压缩的关键在于Bitmap.compress()函数，该函数不会改变图像的大小，但是可以降低图像的质量，从而降低存储大小，进而达到压缩的目的。





[也谈图片压缩](http://zhengxiaoyong.me/2017/04/23/%E4%B9%9F%E8%B0%88%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/)  



[QQ音乐团队分享：Android中的图片压缩技术详解](http://www.52im.net/thread-1208-1-1.html)



[为什么图片反复压缩后会普遍会变绿而不是其他颜色](https://www.zhihu.com/question/29355920)



[图片压缩原理](https://blog.csdn.net/u012416928/article/details/41542695)



[Android之优雅地加载大图片](https://www.jianshu.com/p/0f56f35068e2)



[探索Bitmap使用姿势](https://lizhaoxuan.github.io/2017/07/11/%E6%8E%A2%E7%B4%A2Bitmap%E4%BD%BF%E7%94%A8%E5%A7%BF%E5%8A%BF/)





[内存占用/GPU渲染性能优化手记](https://wangfuda.github.io/2017/07/09/nebula_gpu_monitor_optimize/)



[Android平台图像压缩方案](https://juejin.im/post/5a1bd6595188254cc067981f)
